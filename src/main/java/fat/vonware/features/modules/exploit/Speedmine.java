package fat.vonware.features.modules.exploit;


import fat.vonware.Vonware;
import fat.vonware.event.events.BlockEvent;
import fat.vonware.event.events.PacketEvent;
import fat.vonware.event.events.Render3DEvent;
import fat.vonware.manager.InventoryManager;
import fat.vonware.mixin.mixins.IPlayerControllerMP;
import fat.vonware.features.modules.Module;
import fat.vonware.features.setting.Setting;
import fat.vonware.util.RenderUtil;
import fat.vonware.util.Timer;
import net.minecraft.block.Block;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Enchantments;
import net.minecraft.init.MobEffects;
import net.minecraft.inventory.ClickType;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.CPacketClickWindow;
import net.minecraft.network.play.client.CPacketConfirmTransaction;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.potion.PotionEffect;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.awt.*;

public class Speedmine extends Module {
    public static Speedmine INSTANCE;
    private static float mineDamage;
    private final Setting<MineModa> mineMod = this.register(new Setting<>("MineType", MineModa.Packet));
    public Setting < Boolean > render = this.register ( new Setting <> ( "Render" , false ) );
    public Setting < Integer > red = this.register ( new Setting < Object > ( "Red" , 125 , 0 , 255 , v -> this.render.getValue ( ) ) );
    public Setting < Integer > green = this.register ( new Setting < Object > ( "Green" , 0 , 0 , 255 , v -> this.render.getValue ( ) ) );
    public Setting < Integer > blue = this.register ( new Setting < Object > ( "Blue" , 255 , 0 , 255 , v -> this.render.getValue ( ) ) );
    public Setting < Boolean > box = this.register ( new Setting < Object > ( "Box" , Boolean.FALSE , v -> this.render.getValue ( ) ) );
    private final Setting < Integer > boxAlpha = this.register ( new Setting < Object > ( "BoxAlpha" , 85 , 0 , 255 , v -> this.box.getValue ( ) && this.render.getValue ( ) ) );
    public Setting < Boolean > outline = this.register ( new Setting < Object > ( "Outline" , Boolean.TRUE , v -> this.render.getValue ( ) ) );
    public final Setting < Float > lineWidth = this.register ( new Setting < Object > ( "LineWidth" , 1.0f , 0.1f , 5.0f , v -> this.outline.getValue ( ) && this.render.getValue ( ) ) );

    public final Timer timer = new Timer ( );
    public static BlockPos breakPos;
    public static BlockPos breakPos2;
    private final Setting<InventoryManager.Switch> mineSwitch = this.register(new Setting<InventoryManager.Switch>("SwitchMode", InventoryManager.Switch.PACKET, v -> this.mineMod.getValue() == MineModa.Packet));
    private final Setting<Boolean> strict = this.register(new Setting<Boolean>("Strict", false, v -> this.mineMod.getValue() == MineModa.Packet));
    private final Setting<Boolean> pickOnly = this.register(new Setting<Boolean>("Pickaxe Only", false));
    private final Setting<Double> range = this.register(new Setting<Double>("Range", 6.0, 0.0, 10.0, v -> this.mineMod.getValue() == MineModa.Packet));
    private final Setting<Float> startDamage = this.register(new Setting<Float>("StartDamage", 0.0f, 0.0f, 1.0f, v -> this.mineMod.getValue() == MineModa.Damage));
    private final Setting<Float> endDamage = this.register(new Setting<Float>("EndDamage", 1.0f, 0.0f, 1.0f, v -> this.mineMod.getValue() == MineModa.Damage));
    private final Setting<Boolean> swing = this.register(new Setting<Boolean>("Swing", false, v -> this.mineMod.getValue() == MineModa.Packet));
    private final Setting<Boolean> abortPacket = this.register(new Setting<Boolean>("AbortPacket", true, v -> this.mineMod.getValue() == MineModa.Packet));
    private final Setting<Boolean> rotate = this.register(new Setting<Boolean>("Rotate", false, v -> this.mineMod.getValue() == MineModa.Packet));
    private final Setting<Float> rotateOnDamage = this.register(new Setting<Float>("RotateOnDamage", 0.95f, 0.0f, 1.0f, v -> this.rotate.getValue() && this.mineMod.getValue() == MineModa.Packet));
    private final Setting<Float> rotateStopOnDamage = this.register(new Setting<Float>("RotateStopOnDamage", 1.0f, 0.0f, 1.0f, v -> this.rotate.getValue() && this.mineMod.getValue() == MineModa.Packet));
    private final Setting<Boolean> noDelay = this.register(new Setting<Boolean>("NoDelay", false, v -> this.mineMod.getValue() == MineModa.Packet));
    private final Setting<Integer> maxReBreaks = this.register(new Setting<Integer>("Max Re-Mines", 1, 1, 10, v -> this.mineMod.getValue() == MineModa.Packet));
    private int mineBreaks;
    public IBlockState currentBlockState;
    private int previousHaste;
    private EnumFacing mineFacing;
    private BlockPos minePosition;

    public Speedmine() {
        super("Speedmine", "Mines faster.", Module.Category.EXPLOIT, true, false, false);
        this.setInstance ( );
    }

    public static Speedmine getInstance ( ) {
        if ( INSTANCE == null ) {
            INSTANCE = new Speedmine( );
        }
        return INSTANCE;
    }

    private
    void setInstance ( ) {
        INSTANCE = this;
    }

    @Override
    public void onEnable() {
        if (Speedmine.mc.player.isPotionActive(MobEffects.HASTE)) {
            this.previousHaste = Speedmine.mc.player.getActivePotionEffect(MobEffects.HASTE).getDuration();
        }
    }

    @SubscribeEvent
    public void onPacketSend(PacketEvent.Send send) {
        if (send.getPacket() instanceof CPacketHeldItemChange && this.strict.getValue().booleanValue()) {
            mineDamage = 0.0f;
        }
    }

    public float getBlockStrength(IBlockState iBlockState, BlockPos blockPos) {
        float f = iBlockState.getBlockHardness(Speedmine.mc.world, blockPos);
        if (f < 0.0f) {
            return 0.0f;
        }
        if (!this.canHarvestBlock(iBlockState.getBlock(), blockPos)) {
            return this.getDigSpeed(iBlockState) / f / 100.0f;
        }
        return this.getDigSpeed(iBlockState) / f / 30.0f;
    }

    public float getDigSpeed(IBlockState iBlockState) {
        ItemStack itemStack;
        int n;
        float f = this.getDestroySpeed(iBlockState);
        if (f > 1.0f && (n = EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY, itemStack = this.getEfficientItem(iBlockState))) > 0 && !itemStack.isEmpty()) {
            f = (float) ((double) f + (StrictMath.pow(n, 2.0) + 1.0));
        }
        if (Speedmine.mc.player.isPotionActive(MobEffects.HASTE)) {
            f *= 1.0f + (float) (Speedmine.mc.player.getActivePotionEffect(MobEffects.HASTE).getAmplifier() + 1) * 0.2f;
        }
        if (Speedmine.mc.player.isPotionActive(MobEffects.MINING_FATIGUE)) {
            float f2;
            switch (Speedmine.mc.player.getActivePotionEffect(MobEffects.MINING_FATIGUE).getAmplifier()) {
                case 0: {
                    f2 = 0.3f;
                    break;
                }
                case 1: {
                    f2 = 0.09f;
                    break;
                }
                case 2: {
                    f2 = 0.0027f;
                    break;
                }
                default: {
                    f2 = 8.1E-4f;
                }
            }
            f *= f2;
        }
        if (Speedmine.mc.player.isInsideOfMaterial(Material.WATER) && !EnchantmentHelper.getAquaAffinityModifier(Speedmine.mc.player)) {
            f /= 5.0f;
        }
        if (!Speedmine.mc.player.onGround) {
            f /= 5.0f;
        }
        return f < 0.0f ? 0.0f : f;
    }

    public float getDestroySpeed(IBlockState iBlockState) {
        float f = 1.0f;
        if (this.getEfficientItem(iBlockState) != null && !this.getEfficientItem(iBlockState).isEmpty()) {
            f *= this.getEfficientItem(iBlockState).getDestroySpeed(iBlockState);
        }
        return f;
    }

    @Override
    public void onTick() {

        if (noDelay.getValue()) {
            mc.playerController.blockHitDelay = 0;
        }
        if (this.pickOnly.getValue().booleanValue() && !(Speedmine.mc.player.inventory.getCurrentItem().getItem() instanceof ItemPickaxe)) {
            return;
        }
        if (!Speedmine.mc.player.capabilities.isCreativeMode) {
            if (this.minePosition != null) {
                double d = Speedmine.getDistanceToCenter(Speedmine.mc.player, this.minePosition);
                if (this.mineBreaks >= this.maxReBreaks.getValue() || d > this.range.getValue()) {
                    this.minePosition = null;
                    this.mineFacing = null;
                    mineDamage = 0.0f;
                    this.mineBreaks = 0;
                }
            }
            if (this.mineMod.getValue() == MineModa.Damage) {
                if (((IPlayerControllerMP) mc.playerController).getCurrentBlockDamage() < startDamage.getValue())
                    ((IPlayerControllerMP) mc.playerController).setCurrentBlockDamage(startDamage.getValue());
                if (((IPlayerControllerMP) mc.playerController).getCurrentBlockDamage() >= endDamage.getValue())
                    ((IPlayerControllerMP) mc.playerController).setCurrentBlockDamage(1f);
            } else {
                if (this.minePosition != null && !Speedmine.mc.world.isAirBlock(this.minePosition)) {

                    if (mineDamage >= 1.0f) {

                        ItemStack itemStack;
                        short s;
                        int n = Speedmine.mc.player.inventory.currentItem;
                        int n2 = Vonware.inventoryManager.searchSlot(this.getEfficientItem(Speedmine.mc.world.getBlockState(this.minePosition)).getItem(), InventoryManager.InventoryRegion.HOTBAR) + 36;

                        if (mineMod.getValue() == MineModa.Instant) {
                            Vonware.inventoryManager.switchToItem(this.getEfficientItem(Speedmine.mc.world.getBlockState(this.minePosition)).getItem(), this.mineSwitch.getValue());

                            Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.minePosition, this.mineFacing));
                            Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, this.minePosition, EnumFacing.UP));
                            Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.minePosition, this.mineFacing));
                            if (n != -1) {
                                Vonware.inventoryManager.switchToSlot(n, InventoryManager.Switch.PACKET);
                            }

                        } else {
                            if (this.strict.getValue().booleanValue()) {
                                s = Speedmine.mc.player.openContainer.getNextTransactionID(Speedmine.mc.player.inventory);
                                itemStack = Speedmine.mc.player.openContainer.slotClick(n2, Speedmine.mc.player.inventory.currentItem, ClickType.SWAP, Speedmine.mc.player);
                                Speedmine.mc.player.connection.sendPacket(new CPacketClickWindow(Speedmine.mc.player.inventoryContainer.windowId, n2, Speedmine.mc.player.inventory.currentItem, ClickType.SWAP, itemStack, s));
                            } else {
                                Vonware.inventoryManager.switchToItem(this.getEfficientItem(Speedmine.mc.world.getBlockState(this.minePosition)).getItem(), this.mineSwitch.getValue());
                            }
                            Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.minePosition, this.mineFacing));
                            if (this.abortPacket.getValue().booleanValue()) {
                                Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, this.minePosition, EnumFacing.UP));
                            }
                            if (this.strict.getValue().booleanValue()) {
                                Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, this.minePosition, this.mineFacing));
                            }
                            Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.minePosition, this.mineFacing));
                            if (n != -1) {
                                if (this.strict.getValue().booleanValue()) {
                                    s = Speedmine.mc.player.openContainer.getNextTransactionID(Speedmine.mc.player.inventory);
                                    itemStack = Speedmine.mc.player.openContainer.slotClick(n2, Speedmine.mc.player.inventory.currentItem, ClickType.SWAP, Speedmine.mc.player);
                                    Speedmine.mc.player.connection.sendPacket(new CPacketClickWindow(Speedmine.mc.player.inventoryContainer.windowId, n2, Speedmine.mc.player.inventory.currentItem, ClickType.SWAP, itemStack, s));
                                    Speedmine.mc.player.connection.sendPacket(new CPacketConfirmTransaction(Speedmine.mc.player.inventoryContainer.windowId, s, true));
                                } else {
                                    Vonware.inventoryManager.switchToSlot(n, InventoryManager.Switch.PACKET);
                                }
                            }
                            mineDamage = 0.0f;

                            ++this.mineBreaks;
                        }
                    }

                    if ((double) mineDamage >= (double) this.rotateOnDamage.getValue() && this.rotate.getValue().booleanValue()) {
                        if ((double) mineDamage < (double) this.rotateStopOnDamage.getValue()) {
                            Speedmine.rotatePacket(this.minePosition);
                        }
                    }
                    mineDamage += this.getBlockStrength(Speedmine.mc.world.getBlockState(this.minePosition), this.minePosition);
                }
            }
        }
    }

    public boolean canHarvestBlock(Block block, BlockPos blockPos) {
        IBlockState iBlockState = Speedmine.mc.world.getBlockState(blockPos);
        IBlockState iBlockState2 = iBlockState.getBlock().getActualState(iBlockState, Speedmine.mc.world, blockPos);
        if (iBlockState2.getMaterial().isToolNotRequired()) {

            return true;
        }
        ItemStack itemStack = this.getEfficientItem(iBlockState2);
        String string = block.getHarvestTool(iBlockState2);
        if (itemStack.isEmpty() || string == null) {
            return Speedmine.mc.player.canHarvestBlock(iBlockState2);
        }
        int n = itemStack.getItem().getHarvestLevel(itemStack, string, Speedmine.mc.player, iBlockState2);
        if (n < 0) {
            return Speedmine.mc.player.canHarvestBlock(iBlockState2);
        }
        return n >= block.getHarvestLevel(iBlockState2);
    }

    public ItemStack getEfficientItem(IBlockState iBlockState) {
        int n = -1;
        double d = 0.0;
        for (int i = 0; i < 9; ++i) {
            float f;
            if (Speedmine.mc.player.inventory.getStackInSlot(i).isEmpty() || !((f = Speedmine.mc.player.inventory.getStackInSlot(i).getDestroySpeed(iBlockState)) > 1.0f))
                continue;
            if (EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY, Speedmine.mc.player.inventory.getStackInSlot(i)) > 0) {
                f = (float) ((double) f + (StrictMath.pow(EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY, Speedmine.mc.player.inventory.getStackInSlot(i)), 2.0) + 1.0));
            }
            if (!((double) f > d)) continue;
            d = f;
            n = i;
        }
        if (n != -1) {
            return Speedmine.mc.player.inventory.getStackInSlot(n);
        }
        return Speedmine.mc.player.inventory.getStackInSlot(Speedmine.mc.player.inventory.currentItem);
    }

    @SubscribeEvent
    public void onBlockEvent(BlockEvent blockEvent) {
        if (Speedmine.canBreak(blockEvent.pos) && !Speedmine.mc.player.capabilities.isCreativeMode && !blockEvent.pos.equals(this.minePosition)) {
            this.minePosition = blockEvent.pos;
            this.mineFacing = blockEvent.facing;
            mineDamage = 0.0f;
            this.mineBreaks = 0;
            if (this.swing.getValue().booleanValue()) {
                Speedmine.mc.player.swingArm(EnumHand.MAIN_HAND);
            }
            if (this.minePosition != null && this.mineFacing != null) {
                Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, this.minePosition, this.mineFacing));
                Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, this.minePosition, EnumFacing.UP));
            }
        }
    }

    @Override
    public
    void onRender3D ( Render3DEvent render3DEvent ) {
        if ( this.render.getValue ( ) && this.minePosition != null ) {
            Color color = new Color ( this.red.getValue ( ) , this.green.getValue ( ) , this.blue.getValue ( ) , this.boxAlpha.getValue ( ) );
            RenderUtil.boxESP ( this.minePosition , color , this.lineWidth.getValue ( ) , this.outline.getValue ( ) , this.box.getValue ( ) , this.boxAlpha.getValue ( ) , true );
        }
    }

    @Override
    public void onDisable() {
        if (Speedmine.mc.player.isPotionActive(MobEffects.HASTE)) {
            Speedmine.mc.player.removePotionEffect(MobEffects.HASTE);
        }
        if (this.previousHaste > 0) {
            Speedmine.mc.player.addPotionEffect(new PotionEffect(MobEffects.HASTE, this.previousHaste));
        }
        this.minePosition = null;
        this.mineFacing = null;
        mineDamage = 0.0f;
        this.mineBreaks = 0;
    }

    public static boolean canBreak(BlockPos pos) {
        IBlockState blockState = mc.world.getBlockState(pos);
        Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, mc.world, pos) != -1.0f;
    }

    public static double getDistanceToCenter(EntityPlayer entityPlayer, BlockPos blockPos) {
        double d = (double) blockPos.getX() + 0.5 - entityPlayer.posX;
        double d2 = (double) blockPos.getY() + 0.5 - entityPlayer.posY;
        double d3 = (double) blockPos.getZ() + 0.5 - entityPlayer.posZ;
        return StrictMath.sqrt(d * d + d2 * d2 + d3 * d3);
    }

    public static void rotatePacket(BlockPos pos) {
        double diffX = pos.getX() - mc.player.posX + 0.5;
        double diffY = pos.getY() - (mc.player.posY + (double) mc.player.getEyeHeight());
        double diffZ = pos.getZ() - mc.player.posZ + 0.5;
        double diffXZ = Math.sqrt(diffX * diffX + diffZ * diffZ);
        float yaw = (float) Math.toDegrees(Math.atan2(diffZ, diffX)) - 90.0F;
        float pitch = (float) (-Math.toDegrees(Math.atan2(diffY, diffXZ)));
        Speedmine.mc.player.connection.sendPacket(new CPacketPlayer.Rotation(yaw, pitch, mc.player.onGround));
    }

    public static enum MineModa {
        Packet, Instant, Damage;
    }
}